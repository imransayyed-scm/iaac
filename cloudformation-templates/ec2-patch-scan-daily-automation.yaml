AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Full CloudFormation stack for EC2 patch scanning using SSM.
  Sends scan results to S3 and notifies AppOwner via SNS and SES, tracking email subscriptions via DynamoDB.

Resources:

  PatchScanBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: ec2-patch-automation
      VersioningConfiguration:
        Status: Enabled

  SubscribedEmailsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: SubscribedEmails
      AttributeDefinitions:
        - AttributeName: Email
          AttributeType: S
      KeySchema:
        - AttributeName: Email
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  DailyPatchScanSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: daily-patch-scan-result

  PatchScanLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: PatchScanLambdaExecutionRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: PatchScanLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - ssm:SendCommand
                  - ssm:ListCommandInvocations
                  - ssm:DescribeInstancePatchStates
                  - s3:PutObject
                  - sns:Publish
                  - sns:Subscribe
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  PatchScanLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PatchScanLambda
      Handler: index.lambda_handler
      Runtime: python3.12
      Timeout: 900
      Role: !GetAtt PatchScanLambdaRole.Arn
      Environment:
        Variables:
          BUCKET_NAME: ec2-patch-automation
          S3_KEY_PREFIX: scans
          SNS_TOPIC_ARN: !Ref DailyPatchScanSNSTopic
          DDB_TABLE_NAME: SubscribedEmails
      Code:
        ZipFile: |
          import boto3
          import json
          import datetime
          import time
          import os

          ec2 = boto3.client('ec2')
          ssm = boto3.client('ssm')
          s3 = boto3.client('s3')
          sns = boto3.client('sns')
          ddb = boto3.client('dynamodb')

          BUCKET_NAME = os.environ['BUCKET_NAME']
          S3_KEY_PREFIX = os.environ['S3_KEY_PREFIX']
          SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
          DDB_TABLE_NAME = os.environ['DDB_TABLE_NAME']

          def is_email_subscribed(email):
              try:
                  response = ddb.get_item(
                      TableName=DDB_TABLE_NAME,
                      Key={'Email': {'S': email}}
                  )
                  return 'Item' in response
              except Exception as e:
                  return False

          def lambda_handler(event, context):
              today = datetime.datetime.utcnow().strftime('%Y-%m-%d')
              s3_key = f"{S3_KEY_PREFIX}/{today}-scan-results.json"

              tag_filters = [
                  {'Name': 'tag:PatchScanAutomation', 'Values': ['Enabled']},
                  {'Name': 'tag:PatchScanAutomationWindow', 'Values': ['Daily']},
                  {'Name': 'instance-state-name', 'Values': ['running']}
              ]

              instances = ec2.describe_instances(Filters=tag_filters)
              instance_map = {}
              instance_ids = []

              for reservation in instances['Reservations']:
                  for instance in reservation['Instances']:
                      instance_id = instance['InstanceId']
                      instance_ids.append(instance_id)
                      tags = {t['Key']: t['Value'] for t in instance.get('Tags', [])}
                      instance_map[instance_id] = {
                          'AppOwner': tags.get('AppOwner'),
                          'Tags': tags
                      }

              if not instance_ids:
                  return {"message": "No matching EC2 instances found."}

              response = ssm.send_command(
                  InstanceIds=instance_ids,
                  DocumentName="AWS-RunPatchBaseline",
                  Parameters={"Operation": ["Scan"]},
                  TimeoutSeconds=600
              )

              command_id = response['Command']['CommandId']

              for _ in range(40):
                  time.sleep(15)
                  invocations = ssm.list_command_invocations(
                      CommandId=command_id,
                      Details=True
                  )
                  statuses = [i['Status'] for i in invocations['CommandInvocations']]
                  if all(s in ['Success', 'Failed', 'Cancelled', 'TimedOut'] for s in statuses):
                      break

              compliance_summary = []

              for instance_id in instance_ids:
                  try:
                      result = ssm.describe_instance_patch_states(InstanceIds=[instance_id])
                      state = result['InstancePatchStates'][0]
                      summary = {
                          'InstanceId': instance_id,
                          'PatchGroup': state.get('PatchGroup', 'N/A'),
                          'InstalledCount': state.get('InstalledCount', 0),
                          'MissingCount': state.get('MissingCount', 0),
                          'FailedCount': state.get('FailedCount', 0),
                          'OperationStartTime': str(state.get('OperationStartTime')),
                          'OperationEndTime': str(state.get('OperationEndTime')),
                          'ComplianceStatus': state.get('ComplianceStatus'),
                      }
                      compliance_summary.append(summary)

                      app_owner = instance_map[instance_id].get('AppOwner')
                      if app_owner and "@" in app_owner and not is_email_subscribed(app_owner):
                          sns.subscribe(
                              TopicArn=SNS_TOPIC_ARN,
                              Protocol='email',
                              Endpoint=app_owner
                          )
                          ddb.put_item(
                              TableName=DDB_TABLE_NAME,
                              Item={'Email': {'S': app_owner}}
                          )
                      if app_owner and "@" in app_owner:
                          sns.publish(
                              TopicArn=SNS_TOPIC_ARN,
                              Subject=f"[PatchScan] {instance_id} - {summary['ComplianceStatus']}",
                              Message=json.dumps(summary, indent=2)
                          )
                  except Exception as e:
                      compliance_summary.append({
                          'InstanceId': instance_id,
                          'Error': str(e)
                      })

              s3.put_object(
                  Bucket=BUCKET_NAME,
                  Key=s3_key,
                  Body=json.dumps(compliance_summary, indent=2),
                  ContentType='application/json'
              )

              return {
                  'message': f"Patch scan complete for {len(instance_ids)} instances",
                  's3_result_path': f"s3://{BUCKET_NAME}/{s3_key}",
                  'results': compliance_summary
              }

  PatchScanLambdaSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: PatchScanWeekdaySchedule
      ScheduleExpression: cron(30 9 ? * 2-5 *)  # 3:00 PM IST
      State: ENABLED
      Targets:
        - Arn: !GetAtt PatchScanLambdaFunction.Arn
          Id: PatchScanLambdaTarget

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PatchScanLambdaFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt PatchScanLambdaSchedule.Arn

Outputs:
  LambdaFunctionName:
    Description: Patch Scan Lambda Function
    Value: !Ref PatchScanLambdaFunction

  S3BucketName:
    Description: S3 bucket for scan results
    Value: !Ref PatchScanBucket

  SNSTopic:
    Description: SNS Topic for AppOwner patch results
    Value: !Ref DailyPatchScanSNSTopic

  DynamoDBTable:
    Description: DynamoDB table for tracking subscribed emails
    Value: !Ref SubscribedEmailsTable
